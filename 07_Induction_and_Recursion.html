<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Theorem Proving in Lean</title>
<!-- 2015-01-29 Thu 20:44 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="[[http://www.andrew.cmu.edu/user/avigad][Jeremy Avigad]]Jeremy Avigad, [[http://leodemoura.github.io][Leonardo de Moura]]Leonardo de Moura" />
<link rel="stylesheet" href="css/tutorial.css">
<link rel="stylesheet" href="css/code.css">
<script type="text/javascript" charset="utf-8">if(!window.PolymerGestures) { var head = document.getElementsByTagName('head')[0]; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//cdn.jsdelivr.net/polymer.platform/0.4.2/platform.js"; head.appendChild(js); } </script>
<link rel='import' href='juicy-ace-editor.html'>
</head>
<body>
<div id="content">
<h1 class="title">Theorem Proving in Lean</h1>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2"> 7</span> Induction and Recursion</h2>
<div class="outline-text-2" id="text-1">
<p>
Other than the type universes and Pi types, inductively defined types
provide the only means of defining new types in the Calculus of
Inductive Constructions. We have also seen that, fundamentally, the
constructors and the recursors provide the only means of defining
functions on these types. By the propositions-as-types correspondence,
this means that induction is the fundamental method of proof for these
types.
</p>

<p>
Working with induction and recursion is therefore fundamental to
working in the Calculus of Inductive Constructions. For that reason
Lean provides more natural ways of defining recursive functions,
performing pattern matching and writing inductive proofs.  Behind the
scenes, these are "compiled" down into recursors and auxiliary
definitions we covered in previous chapters.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3"> 7.1</span> Pattern Matching</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The <code>cases_on</code> recursor can be used to define functions and prove
theorems by cases. Complicated definitions may use several nested
<code>cases_on</code> applications, and may be hard to read and understand.
Pattern-matching is a more convenient and standard description technique
or defining functions and proving theorems. Actually, Lean supports an extension of
pattern-matching called <i>dependent pattern-matching</i>. Internally,
dependent pattern-matching is compiled using <code>cases_on</code>, <code>no_confusion</code>
and <code>eq.rec</code>. Thus, the compiler is not part of the trusted code
base. A pattern matching definition is of the following form
</p>

<div class="org-src-container">

<pre class="src src-text">definition [name] [parameters] : [domain] &#8594; [codomain],
[name] [patterns_1] := [value_1],
...
[name] [patterns_n] := [value_n]
</pre>
</div>

<p>
The parameters are fixed, and each assignment defines the value of the function
for a different case specified by the given pattern. As a first example, we
define the function <code>sub2</code> for natural numbers:
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-2' mode="ace/mode/lean" readonly="true">open nat

definition sub2 : nat → nat,
sub2 0     := 0,
sub2 1     := 0,
sub2 (a+2) := a

example : sub2 5 = 3 :=
rfl
</juicy-ace-editor><div id='lean-full-code-2' style='display:none'>open nat

definition sub2 : nat → nat,
sub2 0     := 0,
sub2 1     := 0,
sub2 (a+2) := a

example : sub2 5 = 3 :=
rfl
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-2').text());">Try it yourself &raquo;</button></div>
</div>

<p>
The default compilation method guarantees that the pattern matching "equations"
hold definitionally.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-3' mode="ace/mode/lean" readonly="true">example : sub2 0 = 0 :=
rfl

example : sub2 1 = 0 :=
rfl

example (a : nat) : sub2 (a + 2) = a :=
rfl</juicy-ace-editor><div id='lean-full-code-3' style='display:none'>open nat

definition sub2 : nat → nat,
sub2 0     := 0,
sub2 1     := 0,
sub2 (a+2) := a

example : sub2 0 = 0 :=
rfl

example : sub2 1 = 0 :=
rfl

example (a : nat) : sub2 (a + 2) = a :=
rfl
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-3').text());">Try it yourself &raquo;</button></div>
</div>

<p>
We can use the command <code>print definition</code> to inspect how our definition was compiled into
recursors.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-4' mode="ace/mode/lean" readonly="true">print definition sub2</juicy-ace-editor><div id='lean-full-code-4' style='display:none'>open nat

definition sub2 : nat → nat,
sub2 0     := 0,
sub2 1     := 0,
sub2 (a+2) := a

print definition sub2
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-4').text());">Try it yourself &raquo;</button></div>
</div>

<p>
We say a term is a <i>constructor application</i> if it is of the form <code>c a_1 ... a_n</code> where
<code>c</code> is the constructor of some inductive datatype.
Note that in the definition <code>sub2</code>, the terms <code>1</code> and <code>a+2</code> are not constructor applications.
However, the compiler normalizes them at compilation time, and obtains the constructor applications
<code>succ zero</code> and <code>succ (succ a)</code> respectively. This normalization step is just a simple convenience
that allows us to write definitions resembling the ones found in textbooks.
Note that, there is no "magic", the compiler is just using the kernel normalizer/evaluator.
If we had written <code>2+a</code>, the definition would be rejected since <code>2+a</code> does not normalize into a
constructor application.
</p>

<p>
Next, we use pattern-matching for defining Boolean negation <code>neg</code>, and proving that <code>neg (neg b) = b</code>.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-5' mode="ace/mode/lean" readonly="true">open bool

definition neg : bool → bool,
neg tt := ff,
neg ff := tt

theorem neg_neg : ∀ (b : bool), neg (neg b) = b,
neg_neg tt := rfl,   -- proof for neg (neg tt) = tt
neg_neg ff := rfl    -- proof for neg (neg ff) = ff
</juicy-ace-editor><div id='lean-full-code-5' style='display:none'>open bool

definition neg : bool → bool,
neg tt := ff,
neg ff := tt

theorem neg_neg : ∀ (b : bool), neg (neg b) = b,
neg_neg tt := rfl,   -- proof for neg (neg tt) = tt
neg_neg ff := rfl    -- proof for neg (neg ff) = ff
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-5').text());">Try it yourself &raquo;</button></div>
</div>

<p>
As described in previous chapters, Lean inductive datatypes can be parametric.
The following example defines the <code>tail</code> function using pattern matching.
The argument <code>A : Type</code> is a parameter and occurs before <code>:</code> to indicate it
does not participate in the pattern matching. Lean allows parameters to occur
after <code>:</code>, but it cannot pattern match on them.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-6' mode="ace/mode/lean" readonly="true">import data.list
open list

definition tail {A : Type} : list A → list A,
tail nil      := nil,
tail (h :: t) := t

-- Parameter A may occur after ':'
definition tail2 : Π {A : Type}, list A → list A,
tail2 (@nil A) := (@nil A),
tail2 (h :: t) := t

-- @ is allowed on the left-hand-side
definition tail3 : Π {A : Type}, list A → list A,
@tail3 A nil      := nil,
@tail3 A (h :: t) := t

-- A is explicit parameter
definition tail4 : Π (A : Type), list A → list A,
tail4 A nil      := nil,
tail4 A (h :: t) := t
</juicy-ace-editor><div id='lean-full-code-6' style='display:none'>import data.list
open list

definition tail {A : Type} : list A → list A,
tail nil      := nil,
tail (h :: t) := t

-- Parameter A may occur after ':'
definition tail2 : Π {A : Type}, list A → list A,
tail2 (@nil A) := (@nil A),
tail2 (h :: t) := t

-- @ is allowed on the left-hand-side
definition tail3 : Π {A : Type}, list A → list A,
@tail3 A nil      := nil,
@tail3 A (h :: t) := t

-- A is explicit parameter
definition tail4 : Π (A : Type), list A → list A,
tail4 A nil      := nil,
tail4 A (h :: t) := t
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-6').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>


<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3"> 7.2</span> Structural Recursion/Induction</h3>
<div class="outline-text-3" id="text-1-2">
<p>
The default compilation method supports structural recursion:
recursive applications where one of the arguments is a subterm of the
corresponding term on the left-hand-side. Later, we describe
how to compile recursive equations using well-founded recursion.
The main advantage of the default compilation method is that the
recursive equations hold definitionally.
Our first recursive example is the Fibonacci function <code>fib</code>, and the <code>fib_pos</code>
theorem which combines pattern-matching, recursive equations, and calculational
proofs. The theorem <code>fib_pos</code> makes it clear again that there is no
difference between recursion and induction in Lean.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-7' mode="ace/mode/lean" readonly="true">import data.nat
open nat

definition fib : nat → nat,
fib 0     := 1,
fib 1     := 1,
fib (a+2) := fib (a+1) + fib a

-- The defining equations hold definitionally

example : fib 0 = 1 :=
rfl

example : fib 1 = 1 :=
rfl

example (a : nat) : fib (a+2) = fib (a+1) + fib a :=
rfl

-- fib is always positive
theorem fib_pos : ∀ n, 0 &lt; fib n,
fib_pos 0     := show 0 &lt; 1, from zero_lt_succ 0,
fib_pos 1     := show 0 &lt; 1, from zero_lt_succ 0,
fib_pos (a+2) := calc
  0 = 0 + 0             : rfl
... &lt; fib (a+1) + 0     : add_lt_add_right (fib_pos (a+1)) 0
... &lt; fib (a+1) + fib a : add_lt_add_left  (fib_pos a)     (fib (a+1))
... = fib (a+2)         : rfl
</juicy-ace-editor><div id='lean-full-code-7' style='display:none'>import data.nat
open nat

definition fib : nat → nat,
fib 0     := 1,
fib 1     := 1,
fib (a+2) := fib (a+1) + fib a

-- The defining equations hold definitionally

example : fib 0 = 1 :=
rfl

example : fib 1 = 1 :=
rfl

example (a : nat) : fib (a+2) = fib (a+1) + fib a :=
rfl

-- fib is always positive
theorem fib_pos : ∀ n, 0 &lt; fib n,
fib_pos 0     := show 0 &lt; 1, from zero_lt_succ 0,
fib_pos 1     := show 0 &lt; 1, from zero_lt_succ 0,
fib_pos (a+2) := calc
  0 = 0 + 0             : rfl
... &lt; fib (a+1) + 0     : add_lt_add_right (fib_pos (a+1)) 0
... &lt; fib (a+1) + fib a : add_lt_add_left  (fib_pos a)     (fib (a+1))
... = fib (a+2)         : rfl
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-7').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Another classical example is the list <code>append</code> function.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-8' mode="ace/mode/lean" readonly="true">import data.list
open list

definition append {A : Type} : list A → list A → list A,
append nil    l := l,
append (h::t) l := h :: append t l

example : append [1, 2, 3] [4, 5] = [1, 2, 3, 4, 5] :=
rfl
</juicy-ace-editor><div id='lean-full-code-8' style='display:none'>import data.list
open list

definition append {A : Type} : list A → list A → list A,
append nil    l := l,
append (h::t) l := h :: append t l

example : append [1, 2, 3] [4, 5] = [1, 2, 3, 4, 5] :=
rfl
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-8').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3"> 7.3</span> Dependent Pattern-Matching</h3>
<div class="outline-text-3" id="text-1-3">
<p>
All the examples we have seen so far can be easily written
using <code>cases_on</code> and <code>rec_on</code>. However, this is not the case
for indexed inductive families such as <code>vector A n</code>.
A lot of boiler plate code needs to be written to define
very simple functions such as <code>map</code>, <code>zip</code>, <code>unzip</code> using
recursors.
In the next example, we define the indexed inductive family
vector, the tail function and leave as exercise the function <code>map</code>
which maps a function onto each pair of elements coming from
input vectors. We encourage you to try to define <code>map</code> using <code>rec_on</code>,
<code>cases_on</code> and <code>no_confusion</code>.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-9' mode="ace/mode/lean" readonly="true">open nat

inductive vector (A : Type) : nat → Type :=
nil {} : vector A zero,
cons   : Π {n}, A → vector A n → vector A (succ n)

open vector
notation h :: t := cons h t

check @vector.cases_on
-- Π {A : Type}
--   {C : Π (a : ℕ), vector A a → Type}
--   {a : ℕ}
--   (n : vector A a),
--   (e1 : C 0 nil)
--   (e2 : Π {n : ℕ} (a : A) (a_1 : vector A n), C (succ n) (cons a a_1)),
--   C a n

definition tail {A : Type} {n : nat} (v : vector A (succ n)) : vector A n :=
vector.cases_on v
 (fun (e : zero = succ n), nat.no_confusion e)
 (fun (n1 : nat) (h : A) (t : vector A n1) (e : succ n1 = succ n),
    nat.no_confusion e (fun n1_eq_n : n1 = n, eq.rec_on n1_eq_n t))
 (eq.refl (succ n))

definition map {A B C : Type} (f : A → B → C)
	       : Π {n : nat}, vector A n → vector B n → vector C n :=
sorry</juicy-ace-editor><div id='lean-full-code-9' style='display:none'>namespace hide
open nat

inductive vector (A : Type) : nat → Type :=
nil {} : vector A zero,
cons   : Π {n}, A → vector A n → vector A (succ n)

open vector
notation h :: t := cons h t

check @vector.cases_on
-- Π {A : Type}
--   {C : Π (a : ℕ), vector A a → Type}
--   {a : ℕ}
--   (n : vector A a),
--   (e1 : C 0 nil)
--   (e2 : Π {n : ℕ} (a : A) (a_1 : vector A n), C (succ n) (cons a a_1)),
--   C a n

definition tail {A : Type} {n : nat} (v : vector A (succ n)) : vector A n :=
vector.cases_on v
 (fun (e : zero = succ n), nat.no_confusion e)
 (fun (n1 : nat) (h : A) (t : vector A n1) (e : succ n1 = succ n),
    nat.no_confusion e (fun n1_eq_n : n1 = n, eq.rec_on n1_eq_n t))
 (eq.refl (succ n))

definition map {A B C : Type} (f : A → B → C)
	       : Π {n : nat}, vector A n → vector B n → vector C n :=
sorry

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-9').text());">Try it yourself &raquo;</button></div>
</div>

<p>
The main difficulty is to maintain the relationship between the indices.
The extra parameter <code>e</code> in <code>tail</code> is used to "communicate" the relationship
between <code>n</code> and index associated with each minor premise.
Moreover, some cases are "unreachable" (e.g., <code>zero = succ n</code> in the first case at
<code>tail</code>), and the default way to discard them is using <code>no_confusion</code>.
The <code>map</code> function is even more tedious to define. All these functions are trivial
to define using recursive equations. The compiler generates all boiler plate code
automatically for us.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-10' mode="ace/mode/lean" readonly="true">definition head {A : Type} : Π {n}, vector A (succ n) → A,
head (h :: t) := h

definition tail {A : Type} : Π {n}, vector A (succ n) → vector A n,
tail (h :: t) := t

theorem eta {A : Type} : ∀ {n} (v : vector A (succ n)), head v :: tail v = v,
eta (h::t) := rfl

definition map {A B C : Type} (f : A → B → C)
	       : Π {n : nat}, vector A n → vector B n → vector C n,
map nil     nil     := nil,
map (a::va) (b::vb) := f a b :: map va vb

-- The automatically generated definitions for indexed families are not straightforward
print definition map

definition zip {A B : Type} : Π {n}, vector A n → vector B n → vector (A × B) n,
zip nil nil         := nil,
zip (a::va) (b::vb) := (a, b) :: zip va vb</juicy-ace-editor><div id='lean-full-code-10' style='display:none'>namespace hide
open nat

inductive vector (A : Type) : nat → Type :=
nil {} : vector A zero,
cons   : Π {n}, A → vector A n → vector A (succ n)

open vector prod
notation h :: t := cons h t

definition head {A : Type} : Π {n}, vector A (succ n) → A,
head (h :: t) := h

definition tail {A : Type} : Π {n}, vector A (succ n) → vector A n,
tail (h :: t) := t

theorem eta {A : Type} : ∀ {n} (v : vector A (succ n)), head v :: tail v = v,
eta (h::t) := rfl

definition map {A B C : Type} (f : A → B → C)
	       : Π {n : nat}, vector A n → vector B n → vector C n,
map nil     nil     := nil,
map (a::va) (b::vb) := f a b :: map va vb

-- The automatically generated definitions for indexed families are not straightforward
print definition map

definition zip {A B : Type} : Π {n}, vector A n → vector B n → vector (A × B) n,
zip nil nil         := nil,
zip (a::va) (b::vb) := (a, b) :: zip va vb

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-10').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Note that we can omit recursive equations for "unreachable" cases such as <code>head nil</code>.
</p>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3"> 7.4</span> Overlapping Patterns</h3>
<div class="outline-text-3" id="text-1-4">
<p>
We say a set of recursive equations <i>overlap</i> when there is an input that more than
one left-hand-side can match. In the following definition the input <code>0 0</code> matches
the left-hand-side of the first two equations. Should the function return <code>1</code> or <code>2</code>?
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-11' mode="ace/mode/lean" readonly="true">definition f : nat → nat → nat,
f 0     y     := 1,
f x     0     := 2,
f (x+1) (y+1) := 3</juicy-ace-editor><div id='lean-full-code-11' style='display:none'>open nat
definition f : nat → nat → nat,
f 0     y     := 1,
f x     0     := 2,
f (x+1) (y+1) := 3
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-11').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Overlapping patterns are often used to succinctly express complex patterns in data.
Thus, they are allowed in Lean. Lean eliminates the ambiguity by using the first
applicable equation. In the example above, the following equations hold definitionally.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-12' mode="ace/mode/lean" readonly="true">variables (a b : nat)
example : f 0     0     = 1 := rfl
example : f 0     (a+1) = 1 := rfl
example : f (a+1) 0     = 2 := rfl
example : f (a+1) (b+1) = 3 := rfl</juicy-ace-editor><div id='lean-full-code-12' style='display:none'>open nat
definition f : nat → nat → nat,
f 0     y     := 1,
f x     0     := 2,
f (x+1) (y+1) := 3
variables (a b : nat)
example : f 0     0     = 1 := rfl
example : f 0     (a+1) = 1 := rfl
example : f (a+1) 0     = 2 := rfl
example : f (a+1) (b+1) = 3 := rfl
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-12').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3"> 7.5</span> Wildcard Patterns</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Lean also supports <i>wildcard patterns</i> aka anonymous variables <code>_</code>. They are useful to create
patterns where we don't care about the value of a specific argument.
In the function <code>f</code> defined in the previous section, the values of <code>x</code> and <code>y</code> are not used
in the right-hand-side. Here is the same example using wildcards.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-13' mode="ace/mode/lean" readonly="true">open nat
definition f : nat → nat → nat,
f 0  _  := 1,
f _  0  := 2,
f _  _  := 3
variables (a b : nat)
example : f 0     0     = 1 := rfl
example : f 0     (a+1) = 1 := rfl
example : f (a+1) 0     = 2 := rfl
example : f (a+1) (b+1) = 3 := rfl
</juicy-ace-editor><div id='lean-full-code-13' style='display:none'>open nat
definition f : nat → nat → nat,
f 0  _  := 1,
f _  0  := 2,
f _  _  := 3
variables (a b : nat)
example : f 0     0     = 1 := rfl
example : f 0     (a+1) = 1 := rfl
example : f (a+1) 0     = 2 := rfl
example : f (a+1) (b+1) = 3 := rfl
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-13').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3"> 7.6</span> Incomplete Patterns</h3>
<div class="outline-text-3" id="text-1-6">
<p>
Some functional languages support incomplete patterns. In these
languages, the interpreter produces an exception or returns an
arbitrary value for incomplete cases. We can simulate the arbitrary
value approach using inhabited types.
An element of <code>inhabited A</code> is simply a
witness to the fact that there is an element of <code>A</code>. Later, we will
see that <code>inhabited</code> is an instance of a <code>type class</code> in Lean: Lean
can be instructed that suitable base types are inhabited, and can
automatically infer that other constructed types are inhabited on that
basis. The standard library provides the opaque definition <code>arbitrary
A</code> for inhabited types. The function <code>arbitrary A</code> just returns the
witness for <code>A</code>, but since <code>arbitrary A</code> is opaque, we cannot rely on
the witness chosen.
</p>

<p>
We can also use the type <code>option A</code> to simulate incomplete patterns.
The idea is to return <code>some a</code> for the provided patterns, and use <code>none</code>
for the incomplete cases.
</p>

<p>
In the following example we demonstrate both approaches.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-14' mode="ace/mode/lean" readonly="true">open nat option

definition f1 : nat → nat → nat,
f1 0  _  := 1,
f1 _  0  := 2,
f1 _  _  := arbitrary nat -- "incomplete" case

variables (a b : nat)
example : f1 0     0     = 1 := rfl
example : f1 0     (a+1) = 1 := rfl
example : f1 (a+1) 0     = 2 := rfl
example : f1 (a+1) (b+1) = arbitrary nat := rfl

definition f2 : nat → nat → option nat,
f2 0  _  := some 1,
f2 _  0  := some 2,
f2 _  _  := none    -- "incomplete" case

example : f2 0     0     = some 1 := rfl
example : f2 0     (a+1) = some 1 := rfl
example : f2 (a+1) 0     = some 2 := rfl
example : f2 (a+1) (b+1) = none   := rfl
</juicy-ace-editor><div id='lean-full-code-14' style='display:none'>open nat option

definition f1 : nat → nat → nat,
f1 0  _  := 1,
f1 _  0  := 2,
f1 _  _  := arbitrary nat -- "incomplete" case

variables (a b : nat)
example : f1 0     0     = 1 := rfl
example : f1 0     (a+1) = 1 := rfl
example : f1 (a+1) 0     = 2 := rfl
example : f1 (a+1) (b+1) = arbitrary nat := rfl

definition f2 : nat → nat → option nat,
f2 0  _  := some 1,
f2 _  0  := some 2,
f2 _  _  := none    -- "incomplete" case

example : f2 0     0     = some 1 := rfl
example : f2 0     (a+1) = some 1 := rfl
example : f2 (a+1) 0     = some 2 := rfl
example : f2 (a+1) (b+1) = none   := rfl
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-14').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3"> 7.7</span> Inaccessible Terms</h3>
<div class="outline-text-3" id="text-1-7">
<p>
Another complication in dependent pattern matching is that some parts
require constructor matching, and others are just report
specialization. Lean allows users to mark subterms are <i>inaccessible</i>
for parttern matching. These annotations are essential, for example,
when a term occurring in the left-hand-side is not a variable nor a
constructor application. We can view <i>inaccessible</i> terms as
"don't care" patterns.
</p>

<p>
An inaccessible subterm can be declared using one of the following two
notations: <code>⌞t⌟</code> or <code>?(t)</code>. The unicode version is inputed by entering
<code>\cll</code> (corner-lower-left) and <code>\clr</code> (corner-lower-right).
</p>

<p>
In the following example due to Goguen-McBride-McKinna, we declare
an inductive type that defines the property of "being in the image of <code>f</code>".
Then, we equip <code>f</code> with an "inverse". The typing rules forces us to
write <code>f a</code> for the first argument, this term is not a variable nor
a constructor application. We can view elements of the type <code>image_of f b</code> as
evidence that <code>b</code> is in the image of <code>f</code>. The constructor <code>imf</code> is used to
build such evidence.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-15' mode="ace/mode/lean" readonly="true">variables {A B : Type}
inductive image_of (f : A → B) : B → Type :=
imf : Π a, image_of f (f a)

open image_of

definition inv {f : A → B} : Π b, image_of f b → A,
inv ⌞f a⌟ (imf f a) := a
</juicy-ace-editor><div id='lean-full-code-15' style='display:none'>variables {A B : Type}
inductive image_of (f : A → B) : B → Type :=
imf : Π a, image_of f (f a)

open image_of

definition inv {f : A → B} : Π b, image_of f b → A,
inv ⌞f a⌟ (imf f a) := a
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-15').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Inaccessible terms can also be used to reduce the complexity of the generated
definition. Depedent pattern matching is compiled using basically the
<code>cases_on</code> and <code>no_confusion</code> constructions. The number of <code>cases_on</code> introduced
by the compiler can be reduced by marking parts that just report specialization.
In the next example, we define the type of finite ordinals <code>fin n</code>, this type has
<code>n</code> inhabitants. We also define the function <code>to_nat</code> that maps a <code>fin n</code> into a
<code>nat</code>. If we do not mark <code>n+1</code> as inaccessible, the compiler will generate a definition
containing two <code>cases_on</code> expressions. We encourage you to replace
<code>⌞n+1⌟</code> with <code>(n+1)</code> and inspect the generated definition using <code>print definition to_nat</code>.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-16' mode="ace/mode/lean" readonly="true">open nat

inductive fin : nat → Type :=
fz : Π n, fin (succ n),
fs : Π {n}, fin n → fin (succ n)

open fin

definition to_nat : Π {n : nat}, fin n → nat,
@to_nat ⌞n+1⌟ (fz n) := zero,
@to_nat ⌞n+1⌟ (fs f) := succ (to_nat f)</juicy-ace-editor><div id='lean-full-code-16' style='display:none'>namespace hide
open nat

inductive fin : nat → Type :=
fz : Π n, fin (succ n),
fs : Π {n}, fin n → fin (succ n)

open fin

definition to_nat : Π {n : nat}, fin n → nat,
@to_nat ⌞n+1⌟ (fz n) := zero,
@to_nat ⌞n+1⌟ (fs f) := succ (to_nat f)

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-16').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3"> 7.8</span> Match Expressions</h3>
<div class="outline-text-3" id="text-1-8">
<p>
Lean also provides a compiler for <i>match-with</i> expressions found in many functional languages.
It uses essentially the same infrastructure used to compile recursive equations.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-17' mode="ace/mode/lean" readonly="true">definition is_not_zero (a : nat) : bool :=
match a with
 zero   := ff,
 succ _ := tt
end

-- We can use recursive equations and match
variable {A : Type}
variable p : A → bool

definition filter : list A → list A,
filter nil      := nil,
filter (a :: l) :=
  match p a with
    tt := a :: filter l,
    ff := filter l
  end

example : filter is_not_zero [1, 0, 0, 3, 0] = [1, 3] :=
rfl</juicy-ace-editor><div id='lean-full-code-17' style='display:none'>import data.list
open nat bool list

definition is_not_zero (a : nat) : bool :=
match a with
 zero   := ff,
 succ _ := tt
end

-- We can use recursive equations and match
variable {A : Type}
variable p : A → bool

definition filter : list A → list A,
filter nil      := nil,
filter (a :: l) :=
  match p a with
    tt := a :: filter l,
    ff := filter l
  end

example : filter is_not_zero [1, 0, 0, 3, 0] = [1, 3] :=
rfl
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-17').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3"> 7.9</span> Other Examples</h3>
<div class="outline-text-3" id="text-1-9">
<p>
In some definitions, we have to help the compiler by providing some implicit arguments explicitly in the
left-hand-side of recursive equations. If we don't provide the implicit arguments, the elaborator is unable
to solve some placeholders (aka meta-variables) in the nested match expression.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-18' mode="ace/mode/lean" readonly="true">variables {A B : Type}
definition unzip : Π {n : nat}, vector (A × B) n → vector A n × vector B n,
@unzip zero     nil         := (nil, nil),
@unzip (succ n) ((a, b)::v) :=
  match unzip v with
    (va, vb) := (a :: va, b :: vb)
  end

example : unzip ((1, 10) :: (2, 20) :: nil) = (1 :: 2 :: nil, 10 :: 20 :: nil) :=
rfl</juicy-ace-editor><div id='lean-full-code-18' style='display:none'>namespace hide
open nat

inductive vector (A : Type) : nat → Type :=
nil {} : vector A zero,
cons   : Π {n}, A → vector A n → vector A (succ n)

open vector prod
notation h :: t := cons h t

variables {A B : Type}
definition unzip : Π {n : nat}, vector (A × B) n → vector A n × vector B n,
@unzip zero     nil         := (nil, nil),
@unzip (succ n) ((a, b)::v) :=
  match unzip v with
    (va, vb) := (a :: va, b :: vb)
  end

example : unzip ((1, 10) :: (2, 20) :: nil) = (1 :: 2 :: nil, 10 :: 20 :: nil) :=
rfl

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-18').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Next, we define the function <code>diag</code> which extracts the diagonal of a square matrix <code>vector (vector A n) n</code>.
Note that, this function is defined by structural induction. However, the term <code>map tail v</code> is not a subterm
of <code>((a :: va) :: v)</code>. Could you explain what is going on?
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-19' mode="ace/mode/lean" readonly="true">variables {A B : Type}

definition tail : Π {n}, vector A (succ n) → vector A n,
tail (h :: t) := t

definition map (f : A → B)
	       : Π {n : nat}, vector A n → vector B n,
map nil     := nil,
map (a::va) := f a :: map va

definition diag : Π {n : nat}, vector (vector A n) n → vector A n,
diag nil              := nil,
diag ((a :: va) :: v) := a :: diag (map tail v)</juicy-ace-editor><div id='lean-full-code-19' style='display:none'>namespace hide
open nat

inductive vector (A : Type) : nat → Type :=
nil {} : vector A zero,
cons   : Π {n}, A → vector A n → vector A (succ n)

open vector
notation h :: t := cons h t

variables {A B : Type}

definition tail : Π {n}, vector A (succ n) → vector A n,
tail (h :: t) := t

definition map (f : A → B)
	       : Π {n : nat}, vector A n → vector B n,
map nil     := nil,
map (a::va) := f a :: map va

definition diag : Π {n : nat}, vector (vector A n) n → vector A n,
diag nil              := nil,
diag ((a :: va) :: v) := a :: diag (map tail v)

end hide
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-19').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3"> 7.10</span> Well-Founded Recursion</h3>
<div class="outline-text-3" id="text-1-10">
<p>
[TODO: write this section.]
</p>
</div>
</div>
</div>
</div>
</body>
</html>
